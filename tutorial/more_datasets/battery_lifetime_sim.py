#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
4-step policy simulator
Peter Attia
Last modified August 23, 2018

5/20/20: Updated to generalize maximum SOC, charge time, battery cell parameters, and temperature (L. Hung)

INPUTS:
    -C1, C2, C3: C rate parameters (C4 is calculated)
    -mode: 'lo','med','hi'. Three different landscapes
    -sigma: Include cell-to-cell variation
    - seed: Random seed. Set to None for non-deterministic behavior.
    - max_soc: Maximum state of charge (fraction of capacity between 0 and 1)
    - max_time: Charge time (hrs)
    - R: cell radius; default 0.009 m is radius of 18650 cylindrical cell
    - L: cell length; default 0.065 m is length of 18650 cylindrical cell
    - R_int: internal resistance (default 0.017 Ohms)
    - capacity: cell capacity (default 1.1 Ah)
    - Tinit: initial temperature (default 30 deg C)i
    - Tinf: environmental temperature (default 30 deg C)

OUTPUT: Lifetime
"""

import math
import random
import numpy as np


def sim(C1, C2, C3, mode='hi', sigma=164, seed=0, max_soc=0.8, max_time=1./6.,
        R=0.009, L=0.065, R_int=0.017, capacity=1.1, Tinit=30, Tinf=30):

    if seed is not None:
        random.seed(seed*1000+C1*10+C2*20+C3*30)  # deterministic for the same seed

    # Check that parameters are physical
    assert sigma >= 0  # Sampling variation + prediction error. Value of 164 estimated from batch8
    assert (max_soc <= 1.) & (max_soc > 0)
    assert (max_time > 0.) & (C1 > 0.) & (C2 > 0.) & (C3 > 0.)

    step_charge = max_soc / 4.
    time3 = step_charge * (1./C1 + 1./C2 + 1./C3)
    try:
        assert time3 < max_time
    except AssertionError:
        print('Error: incompatible values of (CC1, CC2, CC3):', C1, C2, C3)
        print('Check that {}*(C1^-1 + C2^-1 + C3^-1) < {} (current value: {})'.format(step_charge, max_time, time3))
        raise

    # DETERMINE C4
    C4 = step_charge/(max_time - time3)

    # Cell volume
    V = math.pi * R**2 * L # [=] m^3

    # ESTIMATED PARAMETERS
    # Values for k, Cp, and rho from Drake et al, JPS (2014)
    # http://www.uta.edu/faculty/jaina/MTL/pubs/Drake-JPS2014.pdf
    k = 0.20   # [=] W/m-K, thermal conductivity
    Cp = 1000  # [=] J/kg-K, specific heat capacity
    rho = 2362 # [=] kg/m^3, density

    # Value for rho estimated from mass of cell is in good agreement with above
    # value
    # http://www.a123batteries.com/v/vspfiles/images/pdf/APR18650M1A.pdf
    # rho = (39/1000)/V # [=] kg/m^3, average density

    # Value for h taken from Engineering Toolbox: h = 10 for air, 500 for oil
    h = 10 # [=] W/m^2-K, heat transfer coefficient

    # DEGRADATION PARAMETERS. ESTIMATED FROM SMITH, DAHN ET AL 2011
    if mode == 'lo':
        A = 5e21      # [=] 1/s, pre-exponential constant
        Ea = 0.25    # [=] eV, activation energy
    elif mode == 'med':
        A = 4      # [=] 1/s, pre-exponential constant
        Ea = 0.10    # [=] eV, activation energy
    elif mode == 'hi':
        A = 136      # [=] 1/s, pre-exponential constant
        Ea = 0.122    # [=] eV, activation energy
    else:
        print('Mode not recognized. Please use ''lo'',''med'', or ''high''.')
    kb = 8.617E-5 # [=] eV/K, Boltzmann's constant

    # CALCULATED PARAMETERS
    I1 = C1 * capacity           # [=] A, C1 current
    I2 = C2 * capacity           # [=] A, C2 current
    I3 = C3 * capacity           # [=] A, C1 current
    I4 = C4 * capacity           # [=] A, C2 current
    Qn = step_charge * capacity  # [=] Ah, capacity filled during one step
    t1 = Qn / I1 * 3600          # [=] s, time of C1
    t2 = Qn / I2 * 3600          # [=] s, time of C2
    t3 = Qn / I3 * 3600          # [=] s, time of C3
    t4 = Qn / I4 * 3600          # [=] s, time of C4
    alpha = k/(rho*Cp)      # [=] m^2/s, thermal diffusivity
    power1 = I1**2 * R_int  # [=] W, power generated by cell during C1
    e_gen1 = power1 / V     # [=] W/m^3, volumetric heat generation term
    power2 = I2**2 * R_int  # [=] W, power generated by cell during C2
    e_gen2 = power2 / V     # [=] W/m^3, volumetric heat generation term
    power3 = I3**2 * R_int  # [=] W, power generated by cell during C3
    e_gen3 = power3 / V     # [=] W/m^3, volumetric heat generation term
    power4 = I4**2 * R_int  # [=] W, power generated by cell during C4
    e_gen4 = power4 / V     # [=] W/m^3, volumetric heat generation term

    """"
    --------------------------BEGIN SIMULATION--------------------------
    """

    ## Set up problem
    dr = 0.001 # [=] m, length step
    dt = 20    # [=] s, time step. <2s for minimal error, 5s is reasonable

    N = int(np.round(R/dr + 1))
    r = np.arange(-dr,R+2*dr,dr)
    T = Tinit*np.ones((N+2,1)) # initialize domain to be IC
    #T[N+1,0] = T[N,0]-dr*k*h*(T[N,0]-Tinf) # Env. boundary condition


    # PRE-INITIALIZE VARIABLES
    time = 0
    deg_rates = 0

    def fin_el(Tin, e_gen):
        # FINITE ELEMENT SIMULATION
        mat = np.zeros((N+2,N+2))
        rhs = np.zeros((N+2,1))

        # Internal domain
        for i in np.arange(2,N+1):
            mat[i,i] = (r[i] * dr**2 * dt) * (1/(alpha*dt)+2/(dr**2))
            mat[i,i+1] = (r[i] * dr**2 * dt) * (-1/(2*r[i]*dr)-1/(dr**2))
            mat[i,i-1] = (r[i] * dr**2 * dt) * (1/(2*r[i]*dr)-1/(dr**2))
            rhs[i] = (r[i] * dr**2 * dt) * ( Tin[i,0]/(alpha*dt)+e_gen/k )

        # Boundary condition at r = 0
        mat[0,0] = 1
        mat[0,2] = -1

        # Cartesian singularity at r = 0
        mat[1,1] = (dr ** 2 * dt) * (4/(dr**2))
        mat[1,2] = (dr ** 2 * dt) * ((1/dt - 4/(dr**2)))
        rhs[1]   = (dr ** 2 * dt) * (Tin[1,0]/(dt) + e_gen/k)

        # Boundary condition at r = R
        mat[N+1,N] = -h
        mat[N+1,N+1] = -k/(2*dr)
        mat[N+1,N-1] = k/(2*dr)
        rhs[N+1] = -h*Tinf

        return np.linalg.lstsq(mat,rhs,rcond=None)[0] # T(r)

    ## C1 step
    while time < t1:

        T = fin_el(T, e_gen1)
        time = time + dt

        for Tidx in T:
            deg_rates = deg_rates + A * math.exp(-Ea/(kb*Tidx))

    ## C2 step
    while time < t1 + t2:
        T = fin_el(T, e_gen2)
        time = time + dt

        for Tidx in T:
            deg_rates = deg_rates + A * math.exp(-Ea/(kb*Tidx))

    ## C3 step
    while time < t1 + t2 + t3:

        T = fin_el(T, e_gen3)
        time = time + dt

        for Tidx in T:
            deg_rates = deg_rates + A * math.exp(-Ea/(kb*Tidx))

    ## C4 step
    while time < t1 + t2 + t3 + t4:

        T = fin_el(T, e_gen4)
        time = time + dt

        for Tidx in T:
            deg_rates = deg_rates + A * math.exp(-Ea/(kb*Tidx))

    # arbitrary factor to give lifetimes on the order of 100s of cycles
    if mode == 'lo':
        lifetime_true = int(1/deg_rates/1e10) + 900
    elif mode == 'med':
        lifetime_true = int(1/deg_rates/4e9) + 900
    elif mode == 'hi':
        lifetime_true = int(1/deg_rates/2e10) + 500
    lifetime_meas = int(random.gauss(lifetime_true, sigma))
    if lifetime_meas < 0: lifetime_meas = 1
    # print("Lifetime = " + str(lifetime_meas))
    return lifetime_meas
